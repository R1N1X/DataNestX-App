backend\src\controllers\auth.controller.ts:
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import User, { IUser } from '../models/user';
import { AuthRequest } from '../middleware/authMiddleware';
import mongoose from 'mongoose';
import nodemailer from 'nodemailer';

const JWT_SECRET = process.env.JWT_SECRET || 'supersecretkey';
const allowedRoles = ['buyer', 'seller', 'admin'];

const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

const generateOTP = () => Math.floor(100000 + Math.random() * 900000).toString();

export const registerUser = async (req: Request, res: Response) => {
  const { name, email, password, role } = req.body;
  try {
    if (!name || !email || !password || !role) {
      return res.status(400).json({ error: 'All fields are required' });
    }
    if (!allowedRoles.includes(role)) {
      return res.status(400).json({ error: 'Invalid user role' });
    }
    const existing = await User.findOne({ email: email.toLowerCase() });
    if (existing) return res.status(400).json({ error: 'Email already exists' });

    const user = new User({ name, email: email.toLowerCase(), password, role });
    await user.save();

    const token = jwt.sign({ userId: (user._id as mongoose.Types.ObjectId).toString(), role: user.role }, JWT_SECRET, { expiresIn: '7d' });

    res.status(201).json({
      message: 'User registered successfully',
      token,
      user: user.toObject(),
    });
  } catch (err: any) {
    console.error('[auth] Register error:', err);
    if (err.name === 'ValidationError') {
      return res.status(400).json({ error: err.message });
    }
    res.status(500).json({ error: 'Error registering user', details: err.message });
  }
};

export const loginUser = async (req: Request, res: Response) => {
  const { email, password } = req.body;
  try {
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }

    const user = await User.findOne({ email: email.toLowerCase() }).select('+password');
    if (!user) return res.status(404).json({ error: 'User not found' });

    const isValid = await user.comparePassword(password);
    if (!isValid) return res.status(401).json({ error: 'Invalid credentials' });

    const otp = generateOTP();
    user.otp = otp;
    user.otpExpires = new Date(Date.now() + 10 * 60 * 1000);
    await user.save();

    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: user.email,
      subject: 'DataNestX OTP for Login',
      html: `<p>Your one-time password (OTP) for DataNestX login is: <strong>${otp}</strong></p><p>This OTP is valid for 10 minutes.</p>`,
    };

    transporter.sendMail(mailOptions, (error: any, info: any) => {
      if (error) {
        console.error('Error sending OTP email:', error);
        return res.status(500).json({ error: 'Failed to send OTP email.' });
      }
      console.log('OTP email sent:', info.response);
      res.json({ message: 'OTP sent to your email. Please verify to log in.' });
    });
  } catch (err: any) {
    console.error('[auth] Login error:', err);
    res.status(500).json({ error: 'Error logging in', details: err.message });
  }
};

export const verifyOTP = async (req: Request, res: Response) => {
  const { email, otp } = req.body;
  try {
    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    if (user.otp !== otp || (user.otpExpires && new Date() > user.otpExpires)) {
      return res.status(401).json({ error: 'Invalid or expired OTP.' });
    }

    user.otp = undefined;
    user.otpExpires = undefined;
    await user.save();

    const token = jwt.sign(
      { userId: (user._id as mongoose.Types.ObjectId).toString(), role: user.role },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.json({
      message: 'Logged in successfully',
      token,
      user: user.toObject(),
    });
  } catch (err: any) {
    console.error('[auth] OTP verification error:', err);
    res.status(500).json({ error: 'Error verifying OTP', details: err.message });
  }
};

export const getMe = async (req: AuthRequest, res: Response) => {
  try {
    const user = await User.findById(req.user?.userId).select('-password');
    if (!user) return res.status(404).json({ error: 'User not found' });
    res.json({ user: user.toObject() });
  } catch (err: any) {
    console.error('[auth] /me error:', err);
    res.status(500).json({ error: 'Failed to fetch user info', details: err.message });
  }
};
backend\src\controllers\dataset.controller.ts:
// backend/src/controllers/dataset.controller.ts
import { Request, Response } from 'express';
import { AuthRequest } from '../middleware/authMiddleware';
import Dataset from '../models/Dataset';
import path from 'path';
import fs from 'fs';

export const createDataset = async (req: AuthRequest, res: Response) => {
    try {
        if (req.user?.role !== 'seller') {
            return res.status(403).json({ error: 'Only sellers can upload datasets.' });
        }
        if (!req.file) {
            return res.status(400).json({ error: 'Dataset file is required.' });
        }
        const { title, description, category, format, price, license, tags, dataType } = req.body;
        
        // FIX: Safely handle the 'tags' field to prevent the 'split' error when it's undefined.
        // If 'tags' are not provided, it will now default to an empty array.
        const processedTags = tags ? (Array.isArray(tags) ? tags : tags.split(',').map((tag: string) => tag.trim())) : [];

        const newDataset = new Dataset({
            title, 
            description, 
            category, 
            format, 
            price: Number(price), 
            license,
            tags: processedTags, // Use the safely processed tags
            dataType, 
            seller: req.user.userId,
            file: { 
                filename: req.file.filename, 
                path: req.file.path, 
                mimetype: req.file.mimetype, 
                size: req.file.size 
            },
        });
        await newDataset.save();
        res.status(201).json(newDataset);
    } catch (error: any) {
        if (req.file) { 
            fs.unlink(req.file.path, (err) => { 
                if (err) console.error("Error deleting orphaned file:", err); 
            }); 
        }
        res.status(500).json({ error: "Server error creating dataset.", details: error.message });
    }
};

export const getAllDatasets = async (req: Request, res: Response) => {
    try {
        const datasets = await Dataset.find({ isAvailable: true })
            .populate('seller', 'name avatarUrl rating totalDatasets')
            .sort({ createdAt: -1 });
        res.status(200).json(datasets);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching datasets." });
    }
};

export const getDatasetById = async (req: Request, res: Response) => {
    try {
        const dataset = await Dataset.findById(req.params.id).populate('seller', 'name avatarUrl rating totalDatasets');
        if (!dataset) return res.status(404).json({ error: 'Dataset not found.' });
        res.status(200).json(dataset);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching dataset details." });
    }
};

export const getMyDatasets = async (req: AuthRequest, res: Response) => {
    try {
        if (!req.user || req.user.role !== 'seller') {
            return res.status(403).json({ error: 'Only sellers can view their datasets.' });
        }
        const datasets = await Dataset.find({ seller: req.user.userId }).sort({ createdAt: -1 });
        res.status(200).json(datasets);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching your datasets." });
    }
};

export const downloadDataset = async (req: AuthRequest, res: Response) => {
    try {
        const dataset = await Dataset.findById(req.params.id);
        if (!dataset || !dataset.file) return res.status(404).json({ error: 'Dataset or file not found.' });
        
        const filePath = path.resolve(dataset.file.path);
        
        if (fs.existsSync(filePath)) {
            res.download(filePath, dataset.file.filename);
        } else {
            res.status(404).json({ error: 'File not found on server.' });
        }
    } catch (error: any) {
        res.status(500).json({ error: "Server error downloading file." });
    }
};
backend\src\controllers\datasetRequest.controller.ts:
// backend/src/controllers/datasetRequest.controller.ts
import { Response } from 'express';
import { AuthRequest } from '../middleware/authMiddleware';
import DatasetRequest from '../models/DatasetRequest';
import Proposal from '../models/Proposal'; // Import Proposal model
import mongoose from 'mongoose';

export const createDatasetRequest = async (req: AuthRequest, res: Response) => {
    try {
        if (req.user?.role !== 'buyer') {
            return res.status(403).json({ error: 'Only buyers can create requests.' });
        }
        const newRequest = new DatasetRequest({ ...req.body, buyer: req.user.userId });
        await newRequest.save();
        res.status(201).json(newRequest);
    } catch (error: any) {
        res.status(500).json({ error: "Server error creating request.", details: error.message });
    }
};

export const getAllDatasetRequests = async (req: AuthRequest, res: Response) => {
    try {
        const requests = await DatasetRequest.find({ status: 'open' })
            .populate('buyer', 'name avatarUrl')
            .sort({ createdAt: -1 });
        res.status(200).json(requests);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching requests.", details: error.message });
    }
};

export const getDatasetRequestById = async (req: AuthRequest, res: Response) => {
    try {
        const request = await DatasetRequest.findById(req.params.id).populate('buyer', 'name avatarUrl');
        if (!request) return res.status(404).json({ error: 'Request not found.' });
        res.status(200).json(request);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching request details.", details: error.message });
    }
};

export const getMyRequests = async (req: AuthRequest, res: Response) => {
    try {
        if (!req.user) return res.status(401).json({ error: 'Not authenticated' });
        const requests = await DatasetRequest.find({ buyer: req.user.userId }).sort({ createdAt: -1 });
        res.status(200).json(requests);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching your requests.", details: error.message });
    }
};

export const getAvailableRequests = async (req: AuthRequest, res: Response) => {
    try {
        if (!req.user) {
            return res.status(401).json({ error: 'Not authenticated' });
        }
        const sellerId = new mongoose.Types.ObjectId(req.user.userId);
        const requests = await DatasetRequest.find({
            status: 'open',
            buyer: { $ne: sellerId }
        })
        .populate('buyer', 'name avatarUrl')
        .sort({ createdAt: -1 });
        res.status(200).json(requests);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching available requests." });
    }
};

// NEW: Function to get requests that are 'in_progress' for a specific seller
export const getInProgressRequests = async (req: AuthRequest, res: Response) => {
    try {
        if (!req.user || req.user.role !== 'seller') {
            return res.status(403).json({ error: 'Only sellers can view their active jobs.' });
        }
        const sellerId = new mongoose.Types.ObjectId(req.user.userId);

        // Find all proposals by this seller that have been accepted
        const acceptedProposals = await Proposal.find({ seller: sellerId, status: 'accepted' }).select('request');
        const requestIds = acceptedProposals.map(p => p.request);

        // Find all requests that match these IDs and are in progress
        const requests = await DatasetRequest.find({
            _id: { $in: requestIds },
            status: 'in_progress'
        }).populate('buyer', 'name avatarUrl').sort({ updatedAt: -1 });

        res.status(200).json(requests);
    } catch (error: any) {
        res.status(500).json({ error: "Server error fetching in-progress requests." });
    }
};

backend\src\controllers\payment.controller.ts:
import { Request, Response } from 'express';
import stripe from '../lib/stripe';
import { AuthRequest } from '../middleware/authMiddleware';
import Dataset, { IDataset } from '../models/Dataset';
import User, { IUser } from '../models/user';
import Purchase, { IPurchase } from '../models/purchase';
import Stripe from 'stripe'; // Import Stripe for type checking

export const createPaymentIntent = async (req: AuthRequest, res: Response) => {
    try {
        const { datasetId } = req.body;
        const buyerId = req.user?.userId;

        if (!buyerId) {
            return res.status(401).json({ error: 'Unauthorized: Buyer ID missing.' });
        }
        if (!datasetId) {
            return res.status(400).json({ error: 'Dataset ID is required.' });
        }

        const dataset = await Dataset.findById(datasetId).populate<{ seller: IUser }>('seller');
        if (!dataset) {
            return res.status(404).json({ error: 'Dataset not found.' });
        }
        if (!dataset.isAvailable) {
            return res.status(400).json({ error: 'This dataset has already been sold.' });
        }

        const sellerUser = dataset.seller as IUser;
        if (!sellerUser || !sellerUser.stripeAccountId) {
            return res.status(400).json({ error: 'Seller has not configured their payment account or is not found.' });
        }
        if (!sellerUser.isStripeVerified) {
            console.warn(`Seller ${sellerUser.id} is not Stripe verified. Applying higher fee.`);
        }

        const amount = Math.round(dataset.price * 100);
        if (isNaN(amount) || amount <= 0) {
            return res.status(400).json({ error: 'Invalid dataset price.' });
        }

        const platformFeePercentage = sellerUser.isStripeVerified ? 0.15 : 0.25;
        const applicationFeeAmount = Math.round(amount * platformFeePercentage);

        const paymentIntent = await stripe.paymentIntents.create({
            amount: amount,
            currency: 'cad',
            payment_method_types: ['card'],
            metadata: {
                datasetId: String(dataset.id),
                buyerId: String(buyerId),
                sellerId: String(sellerUser.id),
                stripeAccountId: sellerUser.stripeAccountId,
                type: 'dataset_purchase',
                platformFee: applicationFeeAmount,
            },
            application_fee_amount: applicationFeeAmount,
            transfer_data: {
                destination: sellerUser.stripeAccountId,
            },
            capture_method: 'automatic',
        });

        res.status(200).json({
            clientSecret: paymentIntent.client_secret,
            message: 'Payment Intent created successfully.',
        });
    } catch (err: any) {
        console.error('[payments] Create Payment Intent error:', err);
        res.status(500).json({ error: 'Failed to create payment intent', details: err.message });
    }
};

// Export handleStripeWebhook
export const handleStripeWebhook = async (req: Request, res: Response) => {
    const signature = req.headers['stripe-signature'] as string;
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET as string;

    if (!signature || !webhookSecret) {
        console.warn('Webhook Error: Missing signature or secret.');
        return res.status(400).send('Webhook Error: Missing signature or secret.');
    }

    let event: Stripe.Event;

    try {
        event = stripe.webhooks.constructEvent(req.body, signature, webhookSecret);
    } catch (err: any) {
        console.error(`Webhook signature verification failed: ${err.message}`);
        return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    switch (event.type) {
        case 'payment_intent.succeeded':
            const paymentIntent = event.data.object as Stripe.PaymentIntent;
            console.log(`✅ PaymentIntent successful: ${paymentIntent.id}`);

            const { datasetId, buyerId, sellerId } = paymentIntent.metadata;

            try {
                const existingPurchase = await Purchase.findOne({ stripePaymentId: paymentIntent.id });
                if (existingPurchase) {
                    console.log(`Purchase already processed for PaymentIntent: ${paymentIntent.id}`);
                    return res.status(200).send('Event already handled.');
                }

                const newPurchase = new Purchase({
                    buyer: buyerId,
                    seller: sellerId,
                    dataset: datasetId,
                    amount: paymentIntent.amount,
                    stripePaymentId: paymentIntent.id,
                });
                await newPurchase.save();

                await Dataset.findByIdAndUpdate(datasetId, { isAvailable: false });

                console.log(`Purchase recorded for dataset ${datasetId}. Dataset marked as unavailable.`);

            } catch (dbError) {
                console.error('Error updating database after payment:', dbError);
                return res.status(500).json({ error: 'Database update failed after payment.' });
            }
            break;

        case 'account.updated':
            const account = event.data.object as Stripe.Account;
            console.log(`Stripe Account updated: ${account.id}`);
            try {
                const user = await User.findOne({ stripeAccountId: account.id });
                if (user) {
                    const isVerified = account.charges_enabled && account.payouts_enabled;
                    if (user.isStripeVerified !== isVerified) {
                        user.isStripeVerified = isVerified;
                        await user.save();
                        console.log(`User ${user.id} Stripe verification status updated to ${isVerified}`);
                    }
                }
            } catch (dbError: any) {
                console.error('Error updating user Stripe status from webhook:', dbError);
            }
            break;

        default:
            console.log(`Unhandled event type ${event.type}`);
    }

    res.status(200).send();
};

backend\src\controllers\proposal.controller.ts:
// backend/src/controllers/proposal.controller.ts
import { Response } from 'express';
import { AuthRequest } from '../middleware/authMiddleware';
import Proposal from '../models/Proposal';
import DatasetRequest, { IDatasetRequest } from '../models/DatasetRequest';
import User, { IUser } from '../models/user';
import stripe from '../lib/stripe';
import mongoose from 'mongoose';

// Helper to check if a value is a populated document
function isPopulated(doc: any): doc is { _id: mongoose.Types.ObjectId } {
    return doc && doc._id;
}

export const createProposal = async (req: AuthRequest, res: Response) => {
    try {
        if (req.user?.role !== 'seller') {
            return res.status(403).json({ error: 'Only sellers can send proposals' });
        }

        const { requestId, coverLetter, price, deliveryTime } = req.body;
        const sellerId = req.user.userId;

        if (!requestId || !coverLetter || price === undefined || deliveryTime === undefined) {
            return res.status(400).json({ error: 'Request ID, cover letter, price, and delivery time are required.' });
        }
        
        const datasetRequest = await DatasetRequest.findById(requestId);
        if (!datasetRequest || datasetRequest.status !== 'open') {
            return res.status(400).json({ error: 'This request is not available for proposals.' });
        }

        const existingProposal = await Proposal.findOne({ request: requestId, seller: sellerId });
        if (existingProposal) {
            return res.status(409).json({ error: 'You have already sent a proposal for this request.' });
        }

        const newProposal = new Proposal({
            request: requestId,
            seller: sellerId,
            coverLetter,
            price,
            deliveryTime,
        });
        await newProposal.save();
        res.status(201).json(newProposal);
    } catch (err: any) {
        console.error('[proposals] Create error:', err);
        res.status(500).json({ error: 'Failed to create proposal', details: err.message });
    }
};

export const getProposalsForRequest = async (req: AuthRequest, res: Response) => {
    try {
        const { requestId } = req.params;
        const datasetRequest = await DatasetRequest.findById(requestId);
        if (!datasetRequest) {
            return res.status(404).json({ error: 'Dataset request not found' });
        }
        if (datasetRequest.buyer.toString() !== req.user?.userId) {
            return res.status(403).json({ error: 'Only the request owner can view proposals.' });
        }
        const proposals = await Proposal.find({ request: requestId }).populate('seller', 'name email avatarUrl');
        res.status(200).json(proposals);
    } catch (err: any) {
        res.status(500).json({ error: 'Failed to fetch proposals', details: err.message });
    }
};

// NEW: Function to get all proposals sent by the logged-in seller
export const getSentProposals = async (req: AuthRequest, res: Response) => {
    try {
        if (req.user?.role !== 'seller') {
            return res.status(403).json({ error: 'Only sellers can view their sent proposals.' });
        }
        const proposals = await Proposal.find({ seller: req.user.userId })
            .populate({
                path: 'request',
                select: 'title category status', // Populate details from the request
            })
            .sort({ createdAt: -1 });
        res.status(200).json(proposals);
    } catch (err: any) {
        res.status(500).json({ error: 'Failed to fetch sent proposals', details: err.message });
    }
};


export const acceptProposal = async (req: AuthRequest, res: Response) => {
    try {
        const { id } = req.params;
        const proposal = await Proposal.findById(id).populate<{ request: IDatasetRequest, seller: IUser }>('request').populate('seller');
        
        if (!proposal || !proposal._id || !isPopulated(proposal.request) || !isPopulated(proposal.seller)) {
            return res.status(404).json({ error: 'Proposal or its associated data not found' });
        }

        if (proposal.request.buyer.toString() !== req.user?.userId) {
            return res.status(403).json({ error: 'Not authorized to accept this proposal' });
        }

        if (!proposal.seller.stripeAccountId || !proposal.seller.isStripeVerified) {
            return res.status(400).json({ error: 'The seller has not configured their payment account.' });
        }

        const amountInCents = proposal.price * 100;
        const paymentIntent = await stripe.paymentIntents.create({
            amount: amountInCents,
            currency: 'cad',
            payment_method_types: ['card'],
            capture_method: 'manual',
            application_fee_amount: Math.round(amountInCents * 0.15),
            transfer_data: { destination: proposal.seller.stripeAccountId },
            metadata: { proposalId: proposal._id.toString(), requestId: proposal.request._id.toString() }
        });

        proposal.status = 'accepted';
        proposal.paymentIntentId = paymentIntent.id;
        await proposal.save();
        await DatasetRequest.findByIdAndUpdate(proposal.request._id, { status: 'in_progress' });
        
        res.status(200).json({
            message: 'Proposal accepted. Please complete payment to hold funds in escrow.',
            clientSecret: paymentIntent.client_secret,
            proposal,
        });
    } catch (err: any) {
        res.status(500).json({ error: 'Failed to accept proposal', details: err.message });
    }
};

export const completeProposal = async (req: AuthRequest, res: Response) => {
    try {
        const { id } = req.params;
        const proposal = await Proposal.findById(id);
        if (!proposal) return res.status(404).json({ error: 'Proposal not found' });
        if (proposal.seller.toString() !== req.user?.userId) {
            return res.status(403).json({ error: 'Not authorized to complete this proposal' });
        }
        if (proposal.status !== 'accepted') {
            return res.status(400).json({ error: 'Proposal must be in "accepted" state to be completed.' });
        }
        proposal.status = 'completed';
        await proposal.save();
        res.status(200).json(proposal);
    } catch (err: any) {
        res.status(500).json({ error: 'Failed to mark proposal as complete', details: err.message });
    }
};

export const releaseFunds = async (req: AuthRequest, res: Response) => {
    try {
        const { id } = req.params;
        const proposal = await Proposal.findById(id).populate<{ request: IDatasetRequest }>('request');

        if (!proposal || !proposal._id || !proposal.paymentIntentId || !isPopulated(proposal.request)) {
            return res.status(404).json({ error: 'Proposal or associated data not found' });
        }
        
        if (proposal.request.buyer.toString() !== req.user?.userId) {
            return res.status(403).json({ error: 'Not authorized to release funds' });
        }
        if (proposal.status !== 'completed') {
            return res.status(400).json({ error: 'Work must be marked as complete by the seller before releasing funds.' });
        }

        await stripe.paymentIntents.capture(proposal.paymentIntentId);

        proposal.status = 'paid';
        await proposal.save();
        await DatasetRequest.findByIdAndUpdate(proposal.request._id, { status: 'completed' });

        res.status(200).json({ message: 'Funds released successfully!' });
    } catch (err: any) {
        res.status(500).json({ error: 'Failed to release funds', details: err.message });
    }
};
backend\src\controllers\purchase.controller.ts:
// backend/src/controllers/purchase.controller.ts
import { Response } from 'express';
import { AuthRequest } from '../middleware/authMiddleware';
import Purchase from '../models/purchase';

// @desc    Get purchases for the logged-in user
// @route   GET /api/purchases/me
// @access  Private
export const getMyPurchases = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.user?.userId;
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        const purchases = await Purchase.find({ buyer: userId })
            .sort({ purchaseDate: -1 }) // Show most recent purchases first
            .populate({
                path: 'dataset',
                select: 'title description category format price tags file', // Select fields you want to show
            })
            .populate({
                path: 'seller',
                select: 'name avatarUrl', // Get seller's name and avatar
            });

        res.status(200).json(purchases);

    } catch (error) {
        console.error('Error fetching user purchases:', error);
        res.status(500).json({ error: 'Server error while fetching purchases.' });
    }
};

backend\src\controllers\stripeConnect.controller.ts:
// backend/src/controllers/stripeConnect.controller.ts
import { Response } from 'express';
import stripe from '../lib/stripe';
import User from '../models/user';
import { AuthRequest } from '../middleware/authMiddleware';

export const onboardSeller = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.user?.userId;
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        const user = await User.findById(userId);
        if (!user || user.role !== 'seller') {
            return res.status(403).json({ error: 'Only sellers can onboard with Stripe.' });
        }

        let accountId = user.stripeAccountId;

        if (!accountId) {
            const account = await stripe.accounts.create({
                type: 'express',
                email: user.email,
                capabilities: {
                    card_payments: { requested: true },
                    transfers: { requested: true },
                },
            });
            accountId = account.id;
            user.stripeAccountId = accountId;
            await user.save();
        }

        // --- THIS IS THE FIX ---
        // The CLIENT_ORIGIN now correctly defaults to port 8080, matching your frontend server.
        const clientOrigin = process.env.CLIENT_ORIGIN || 'http://localhost:8080';
        if (!clientOrigin.startsWith('http')) {
            return res.status(500).json({ error: 'Server configuration error: Invalid CLIENT_ORIGIN.' });
        }

        const accountLink = await stripe.accountLinks.create({
            account: accountId,
            refresh_url: `${clientOrigin}/settings?tab=billing`,
            return_url: `${clientOrigin}/settings?tab=billing&stripe_onboarding_success=true`,
            type: 'account_onboarding',
        });

        res.json({ url: accountLink.url });

    } catch (err: any) {
        console.error('[Stripe Connect] Onboarding error:', err);
        res.status(500).json({ error: 'Failed to onboard seller with Stripe', details: err.message });
    }
};

export const getAccountStatus = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.user?.userId;
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        const user = await User.findById(userId);
        if (!user || user.role !== 'seller' || !user.stripeAccountId) {
            return res.status(404).json({ error: 'Stripe account not found for this seller.' });
        }

        const account = await stripe.accounts.retrieve(user.stripeAccountId);
        const isVerified = account.charges_enabled && account.payouts_enabled;

        if (user.isStripeVerified !== isVerified) {
            user.isStripeVerified = isVerified;
            await user.save();
        }

        res.json({
            isVerified: isVerified,
            details: account,
        });

    } catch (err: any) {
        console.error('[Stripe Connect] Account status error:', err);
        res.status(500).json({ error: 'Failed to retrieve Stripe account status', details: err.message });
    }
};

backend\src\controllers\user.controller.ts:
import { Response } from 'express';
import User, { IUser } from '../models/user';
import { AuthRequest } from '../middleware/authMiddleware';
import fs from 'fs';
import path from 'path';

// @desc    Get current user's profile
// @route   GET /api/users/me
// @access  Private
export const getUserProfile = async (req: AuthRequest, res: Response) => {
    try {
        const user = await User.findById(req.user?.userId).select('-password');
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        res.status(200).json({ user: user.toObject() });
    } catch (err: any) {
        console.error('[user] Get profile error:', err);
        res.status(500).json({ error: 'Failed to fetch user profile', details: err.message });
    }
};

// @desc    Update user profile
// @route   PUT /api/users/me
// @access  Private
export const updateUserProfile = async (req: AuthRequest, res: Response) => {
    try {
        const userId = req.user?.userId;
        if (!userId) {
            return res.status(401).json({ error: 'Unauthorized: User ID missing.' });
        }

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        const allowedUpdates = ['name', 'bio', 'location', 'website', 'phone'];
        const updates: { [key: string]: any } = {};
        for (const key of allowedUpdates) {
            if (req.body[key] !== undefined) {
                updates[key] = req.body[key];
            }
        }
        
        // Find and update the user, running validators on the update
        const updatedUser = await User.findByIdAndUpdate(
            userId,
            { $set: updates },
            { new: true, runValidators: true }
        ).select('-password');

        if (!updatedUser) {
            return res.status(404).json({ error: 'User not found after update.' });
        }

        res.status(200).json({ message: 'Profile updated successfully', user: updatedUser.toObject() });
    } catch (err: any) {
        console.error('[user] Update profile error:', err);
        if (err.name === 'ValidationError') {
            return res.status(400).json({ error: err.message });
        }
        res.status(500).json({ error: 'Failed to update profile', details: err.message });
    }
};

// @desc    Upload user avatar
// @route   POST /api/users/me/avatar
// @access  Private
export const uploadUserAvatar = async (req: AuthRequest, res: Response) => {
    const userId = req.user?.userId;
    if (!userId) {
        if (req.file && fs.existsSync(req.file.path)) fs.unlinkSync(req.file.path);
        return res.status(401).json({ error: 'Unauthorized: User ID missing.' });
    }

    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No avatar file uploaded.' });
        }

        const user = await User.findById(userId);
        if (!user) {
            if (req.file && fs.existsSync(req.file.path)) fs.unlinkSync(req.file.path);
            return res.status(404).json({ error: 'User not found during avatar update.' });
        }
        
        // Delete old avatar if it exists and is a local file
        if (user.avatarUrl) {
            const oldAvatarPath = path.join(__dirname, '..', '..', user.avatarUrl);
            if (fs.existsSync(oldAvatarPath)) {
                fs.unlinkSync(oldAvatarPath);
            }
        }
        
        const avatarUrl = `/uploads/avatars/${req.file.filename}`;
        user.avatarUrl = avatarUrl;
        await user.save();

        res.status(200).json({ message: 'Avatar updated successfully', avatarUrl: user.avatarUrl });
    } catch (err: any) {
        console.error('[user] Avatar upload error:', err);
        if (req.file && fs.existsSync(req.file.path)) fs.unlinkSync(req.file.path);
        if (err.name === 'MulterError') {
            return res.status(400).json({ error: `File upload error: ${err.message}` });
        }
        res.status(500).json({ error: 'Server error during avatar upload.', details: err.message });
    }
};
backend\src\controllers\webhook.controller.ts:
// backend/src/controllers/webhook.controller.ts
import { Request, Response } from 'express';
import Stripe from 'stripe';
import stripe from '../lib/stripe';
import Purchase from '../models/purchase';
import Dataset from '../models/Dataset';

export const handleStripeWebhook = async (req: Request, res: Response) => {
    const signature = req.headers['stripe-signature'] as string;
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET as string;

    if (!signature || !webhookSecret) {
        return res.status(400).send('Webhook Error: Missing signature or secret.');
    }

    let event: Stripe.Event;

    try {
        event = stripe.webhooks.constructEvent(req.body, signature, webhookSecret);
    } catch (err: any) {
        console.error(`Webhook signature verification failed: ${err.message}`);
        return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    if (event.type === 'payment_intent.succeeded') {
        const paymentIntent = event.data.object as Stripe.PaymentIntent;
        console.log(`✅ PaymentIntent successful: ${paymentIntent.id}`);
        
        try {
            const { datasetId, buyerId, sellerId } = paymentIntent.metadata;

            const existingPurchase = await Purchase.findOne({ stripePaymentId: paymentIntent.id });
            if (existingPurchase) {
                console.log(`Purchase already processed for PaymentIntent: ${paymentIntent.id}`);
                return res.status(200).send('Event already handled.');
            }

            const newPurchase = new Purchase({
                buyer: buyerId,
                seller: sellerId,
                dataset: datasetId,
                amount: paymentIntent.amount,
                stripePaymentId: paymentIntent.id,
            });
            await newPurchase.save();
            await Dataset.findByIdAndUpdate(datasetId, { isAvailable: false });

            console.log(`Purchase recorded for dataset ${datasetId}.`);

        } catch (dbError) {
            console.error('Error updating database after payment:', dbError);
            return res.status(500).json({ error: 'Database update failed after payment.' });
        }
    } else {
        console.log(`Unhandled event type ${event.type}`);
    }

    res.status(200).send();
};