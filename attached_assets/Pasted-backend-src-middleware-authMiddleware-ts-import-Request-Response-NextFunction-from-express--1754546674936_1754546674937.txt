backend\src\middleware\authMiddleware.ts:
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'supersecretkey';

export interface AuthRequest extends Request {
  user?: {
    userId: string;
    role: 'buyer' | 'seller' | 'admin';
  };
}

export const protect = (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized: No token provided' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as {
      userId: string;
      role: 'buyer' | 'seller' | 'admin';
    };

    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Unauthorized: Invalid or expired token' });
  }
};

backend\src\middleware\upload.ts:
// backend/src/middleware/upload.ts
import multer from 'multer';
import path from 'path';
import fs from 'fs';

// --- General Uploads Directory ---
const uploadsDir = path.join(__dirname, '..', '..', 'uploads'); // Correct path from src/middleware

// --- Avatars Subdirectory ---
const avatarsDir = path.join(uploadsDir, 'avatars');

// Generic function to ensure a directory exists
const ensureDirExists = (dir: string) => {
 if (!fs.existsSync(dir)) {
 try {
 fs.mkdirSync(dir, { recursive: true });
 console.log(`Created directory: ${dir}`);
 } catch (error) {
 console.error(`Error creating directory ${dir}:`, error);
 }
 }
};

// Ensure both directories exist on startup
ensureDirExists(uploadsDir);
ensureDirExists(avatarsDir);


// =================================================================
// 1. ORIGINAL UPLOAD CONFIG (for datasets)
// =================================================================
const storage = multer.diskStorage({
 destination: (req, file, cb) => cb(null, uploadsDir),
 filename: (req, file, cb) => {
 const sanitizedFilename = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
 cb(null, `${Date.now()}-${sanitizedFilename}`);
 }
});

export const upload = multer({
 storage: storage,
 limits: { fileSize: 100 * 1024 * 1024 }, // 100MB for datasets
 fileFilter: (req, file, cb) => cb(null, true), // Basic filter for datasets
});


// =================================================================
// 2. NEW AVATAR UPLOAD CONFIG
// =================================================================
const avatarStorage = multer.diskStorage({
 destination: (req, file, cb) => cb(null, avatarsDir), // Save to the 'avatars' subdirectory
 filename: (req, file, cb) => {
 const fileExt = path.extname(file.originalname);
    // Use user ID for the filename to ensure it's unique per user and easy to find
    const reqWithUser = req as any; // Cast to access user property
 const filename = `${reqWithUser.user.userId}${fileExt}`;
 cb(null, filename);
 }
});

export const uploadAvatar = multer({
 storage: avatarStorage,
 limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit for avatars
 fileFilter: (req, file, cb) => {
 // Allow only common image types
 const allowedTypes = /jpeg|jpg|png|gif/;
 const mimeType = allowedTypes.test(file.mimetype);
 const extName = allowedTypes.test(path.extname(file.originalname).toLowerCase());

 if (mimeType && extName) {
 return cb(null, true);
 }
 cb(new Error('Invalid file type. Only JPEG, PNG, and GIF are allowed.'));
 }
});

backend\src\lib\db.ts:
import mongoose from 'mongoose';

export const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI || '');
    console.log(`MongoDB connected: ${conn.connection.name}`);
  } catch (error) {
    console.error('Error connecting to MongoDB:', error);
    process.exit(1);
  }
};
backend\src\lib\errors.ts:
// backend/src/lib/errors.ts
export class AppError extends Error {
  constructor(
    public readonly code: string,
    public readonly statusCode: number,
    message: string,
    public readonly details?: unknown
  ) {
    super(message);
  }

  toJSON() {
    return {
      error: {
        code: this.code,
        message: this.message,
        details: this.details
      }
    };
  }
}

export class AuthError extends AppError {
  constructor(message = 'Authentication required') {
    super('UNAUTHORIZED', 401, message);
  }
}

export class NotFoundError extends AppError {
  constructor(entity: string) {
    super('NOT_FOUND', 404, `${entity} not found`);
}
}
backend\src\lib\stripe.ts:
// backend/src/lib/stripe.ts
import Stripe from 'stripe';
import dotenv from 'dotenv';

dotenv.config(); // Ensure environment variables are loaded

// Initialize Stripe with your secret key
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'sk_test_YOUR_FALLBACK_SECRET_KEY', {
  apiVersion: '2023-10-16' as any, // Cast to any to bypass strict type checking for apiVersion
  typescript: true, // Enable TypeScript types
});

export default stripe;

backend\src\models\Dataset.ts:
// backend/src/models/Dataset.ts
import mongoose, { Document, Schema } from 'mongoose';

// Define the interface for a Dataset document
export interface IDataset extends Document {
title: string;
description: string;
category: string;
format: string;
price: number;
license: string;
updateFrequency?: string;
tags: string[];
size?: string;
seller: mongoose.Types.ObjectId;
file: {
filename: string;
 mimetype: string;
 path: string;
 size: number;
};
 dataType: 'training' | 'testing';
  isAvailable: boolean; // <-- ADD THIS LINE
 createdAt: Date;
 updatedAt: Date;
}

// Define the Mongoose Schema for Dataset
const DatasetSchema: Schema<IDataset> = new Schema(
 {
  title: { type: String, required: true, trim: true },
 description: { type: String, required: true, trim: true },
 category: { type: String, required: true, trim: true },
 format: { type: String, required: true, trim: true },
 price: { type: Number, required: true, min: 0 },
 license: { type: String, required: true, trim: true },
 updateFrequency: { type: String, trim: true },
 tags: [{ type: String, trim: true }],
 size: { type: String, trim: true },
 seller: { type: Schema.Types.ObjectId, ref: 'User', required: true },
 file: {
 filename: { type: String, required: true },
 mimetype: { type: String, required: true },
 path: { type: String, required: true },
 size: { type: Number, required: true, min: 0 },
 },
 dataType: {
 type: String,
 enum: ['training', 'testing'],
 required: true,
 },
    isAvailable: { type: Boolean, default: true }, // <-- ADD THIS LINE
 },
{
 timestamps: true,
 toJSON: { virtuals: true, /* ... */ },
 toObject: { virtuals: true },
});

const Dataset = mongoose.model<IDataset>('Dataset', DatasetSchema);
export default Dataset;
backend\src\models\DatasetRequest.ts:
import mongoose, { Schema, Document, Types } from 'mongoose';

// Embedded Proposal subdocument interface
export interface IProposal {
  seller: Types.ObjectId;
  message: string;
  quote: number;
  createdAt: Date;
}

// Main DatasetRequest interface
export interface IDatasetRequest extends Document {
  title: string;
  description: string;
  tags: string[];
  budget: {
    min: number;
    max: number;
  };
  deadline: Date;
  buyer: Types.ObjectId;                 // Remember to .populate when querying!
  status: 'open' | 'in_progress' | 'fulfilled' | 'cancelled';
  proposals: IProposal[];
  createdAt: Date;
  updatedAt: Date;
}

// Proposal sub-schema
const ProposalSchema = new Schema<IProposal>(
  {
    seller: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    message: { type: String, required: true },
    quote: { type: Number, required: true },
    createdAt: { type: Date, default: Date.now }
  },
  { _id: false }
);

// Main DatasetRequest schema
const DatasetRequestSchema = new Schema<IDatasetRequest>(
  {
    title: { type: String, required: true },
    description: { type: String, required: true },
    tags: [{ type: String }],
    budget: {
      min: { type: Number, required: true },
      max: { type: Number, required: true }
    },
    deadline: { type: Date, required: true },
    buyer: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    status: {
      type: String,
      enum: ['open', 'in_progress', 'fulfilled', 'cancelled'],
      default: 'open'
    },
    proposals: [ProposalSchema]
  },
  { timestamps: true }
);

// Virtual id
DatasetRequestSchema.virtual('id').get(function (this: any) {
  return this._id.toString();
});
DatasetRequestSchema.set('toJSON', { virtuals: true });
DatasetRequestSchema.set('toObject', { virtuals: true });

export default mongoose.model<IDatasetRequest>('DatasetRequest', DatasetRequestSchema);

backend\src\models\Message.ts:
// backend/src/models/Message.ts
import mongoose, { Schema, Document, Types } from 'mongoose';

// Define the interface for a Message document
export interface IMessage extends Document {
  sender: Types.ObjectId; // Reference to the User who sent the message
  receiver: Types.ObjectId; // Reference to the User who receives the message
  content: string; // The message text
  read: boolean; // Whether the message has been read by the receiver
  // Optional: context for the message (e.g., related to a specific dataset or request)
  dataset?: Types.ObjectId; // Reference to a Dataset if message is about it
  request?: Types.ObjectId; // Reference to a DatasetRequest if message is about it
  createdAt: Date;
  updatedAt: Date;
}

// Define the Mongoose Schema for Message
const MessageSchema: Schema<IMessage> = new Schema(
  {
    sender: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    receiver: { type: Schema.Types.ObjectId, ref: 'User', required: true },
    content: { type: String, required: true, trim: true, maxlength: 1000 }, // Max length for messages
    read: { type: Boolean, default: false },
    dataset: { type: Schema.Types.ObjectId, ref: 'Dataset', index: true }, // Add index for faster lookups
    request: { type: Schema.Types.ObjectId, ref: 'DatasetRequest', index: true }, // Add index for faster lookups
  },
  {
    timestamps: true, // Adds createdAt and updatedAt fields automatically
    toJSON: {
      virtuals: true,
      transform: function (doc, ret: any) {
        ret.id = ret._id.toString();
        delete ret._id;
        delete ret.__v;
      },
    },
    toObject: { virtuals: true },
  }
);

// Add an index for efficient conversation retrieval
// This index allows fetching messages between two users, optionally for a specific context (dataset/request)
MessageSchema.index({
  sender: 1,
  receiver: 1,
  dataset: 1,
  request: 1,
  createdAt: -1
});

// Create and export the Mongoose Model
const Message = mongoose.model<IMessage>('Message', MessageSchema);

export default Message;

backend\src\models\Proposal.ts:
// backend/src/models/Proposal.ts
import mongoose, { Schema, Document, Types } from "mongoose";

export interface IProposal extends Document {
  request: Types.ObjectId;
  seller: Types.ObjectId;
  coverLetter: string; // Correct field name
  price: number;
  deliveryTime: number; // Correct field name (in days)
  status: "pending" | "accepted" | "rejected" | "completed" | "paid" | "cancelled";
  paymentIntentId?: string; // For Stripe escrow
}

const ProposalSchema = new Schema<IProposal>(
  {
    request: { type: Schema.Types.ObjectId, ref: "DatasetRequest", required: true },
    seller: { type: Schema.Types.ObjectId, ref: "User", required: true },
    coverLetter: { type: String, required: true, trim: true, maxlength: 2000 },
    price: { type: Number, required: true, min: 5 },
    deliveryTime: { type: Number, required: true, min: 1 },
    status: {
      type: String,
      enum: ["pending", "accepted", "rejected", "completed", "paid", "cancelled"],
      default: "pending",
    },
    paymentIntentId: { type: String },
  },
  { timestamps: true }
);

const Proposal = mongoose.model<IProposal>("Proposal", ProposalSchema);
export default Proposal;

backend\src\models\purchase.ts:
// backend/src/models/purchase.ts
import { Schema, model, Document, Types } from 'mongoose';

export interface IPurchase extends Document {
  buyer: Types.ObjectId;
  seller: Types.ObjectId;
  dataset: Types.ObjectId;
  amount: number; // Stored in cents
  stripePaymentId: string;
  purchaseDate: Date;
}

const purchaseSchema = new Schema<IPurchase>({
  buyer: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  seller: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  dataset: { type: Schema.Types.ObjectId, ref: 'Dataset', required: true },
  amount: { type: Number, required: true }, // Store amount in cents
  stripePaymentId: { type: String, required: true, unique: true },
}, {
  timestamps: { createdAt: 'purchaseDate', updatedAt: false }, // Use createdAt as purchaseDate
});

const Purchase = model<IPurchase>('Purchase', purchaseSchema);
export default Purchase;
backend\src\routes\auth.routes.ts:
import express from 'express';
// Corrected import casing for User model
import User from '../models/user'; // Changed from '../models/User' to '../models/user'
import { protect, AuthRequest } from '../middleware/authMiddleware';

// Import controller functions for authentication
import {
  registerUser,
  loginUser,
  getMe, // Assuming getMe is now in auth.controller.ts
  verifyOTP // Assuming verifyOTP is also in auth.controller.ts
} from '../controllers/auth.controller';

// IMPORTANT: Validate environment variables on startup
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  throw new Error('FATAL ERROR: JWT_SECRET is not defined in environment variables.');
}

const router = express.Router();
const allowedRoles = ['buyer', 'seller', 'admin']; // This can be removed if only used in controller

// Public authentication routes
router.post('/register', registerUser);
router.post('/login', loginUser);
router.post('/verify-otp', verifyOTP); // New route for OTP verification

// Protected user-related routes (e.g., fetching current user profile)
router.get('/me', protect, getMe);

export default router;

backend\src\routes\dataset.routes.ts:
import express from 'express';
import { protect } from '../middleware/authMiddleware';
import { upload } from '../middleware/upload';
import { createDataset, getAllDatasets, getDatasetById, getMyDatasets, downloadDataset } from '../controllers/dataset.controller';

const router = express.Router();

router.get('/', getAllDatasets);
router.post('/', protect, upload.single('file'), createDataset);
router.get('/my', protect, getMyDatasets);
router.get('/download/:id', protect, downloadDataset);
router.get('/:id', getDatasetById);

export default router;

backend\src\routes\datasetRequest.routes.ts:
// backend/src/routes/datasetRequest.routes.ts
import express from 'express';
import { protect } from '../middleware/authMiddleware';
import { 
    createDatasetRequest, 
    getAllDatasetRequests, 
    getDatasetRequestById, 
    getMyRequests, 
    getAvailableRequests,
    getInProgressRequests // NEW: Import the new controller function
} from '../controllers/datasetRequest.controller';

const router = express.Router();
router.use(protect);

router.route('/').get(getAllDatasetRequests).post(createDatasetRequest);
router.get('/my', getMyRequests);
router.get('/available', getAvailableRequests);

// NEW: Route for sellers to get their active/in-progress jobs
router.get('/in-progress', getInProgressRequests);

router.route('/:id').get(getDatasetRequestById);

export default router;

backend\src\routes\message.routes.ts:
// backend/src/routes/message.routes.ts
import express, { Request, Response } from 'express';
import Message from '../models/Message';
import User from '../models/user'; // To populate sender/receiver details
import Dataset from '../models/Dataset'; // To validate dataset context
import DatasetRequest from '../models/DatasetRequest'; // To validate request context
import { protect, AuthRequest } from '../middleware/authMiddleware';
import mongoose from 'mongoose'; // For ObjectId validation and Types

const router = express.Router();

// POST /api/messages - Send a new message
router.post('/', protect, async (req: AuthRequest, res: Response) => {
  try {
    const { receiverId, content, datasetId, requestId } = req.body;
    const senderId = req.user?.userId;

    if (!senderId) {
      return res.status(401).json({ error: 'Unauthorized: Sender ID missing.' });
    }
    if (!receiverId || !content) {
      return res.status(400).json({ error: 'Receiver ID and content are required.' });
    }
    if (content.length > 1000) {
      return res.status(400).json({ error: 'Message content too long (max 1000 characters).' });
    }

    // Validate receiverId is a valid ObjectId and exists
    if (!mongoose.Types.ObjectId.isValid(receiverId)) {
        return res.status(400).json({ error: 'Invalid receiver ID format.' });
    }
    const receiverExists = await User.findById(receiverId);
    if (!receiverExists) {
      return res.status(404).json({ error: 'Receiver user not found.' });
    }

    // Ensure sender is not sending message to themselves (optional, but good practice)
    if (senderId === receiverId) {
        return res.status(400).json({ error: 'Cannot send message to yourself.' });
    }

    // Validate optional context IDs if provided
    let messageContext: { dataset?: mongoose.Types.ObjectId; request?: mongoose.Types.ObjectId } = {}; // Use mongoose.Types.ObjectId
    if (datasetId) {
      if (!mongoose.Types.ObjectId.isValid(datasetId as string)) {
          return res.status(400).json({ error: 'Invalid dataset ID format.' });
      }
      const dataset = await Dataset.findById(datasetId);
      if (!dataset) {
        return res.status(404).json({ error: 'Associated dataset not found.' });
      }
      messageContext.dataset = new mongoose.Types.ObjectId(datasetId);
    }
    if (requestId) {
      if (!mongoose.Types.ObjectId.isValid(requestId as string)) {
          return res.status(400).json({ error: 'Invalid request ID format.' });
      }
      const request = await DatasetRequest.findById(requestId);
      if (!request) {
        return res.status(404).json({ error: 'Associated dataset request not found.' });
      }
      messageContext.request = new mongoose.Types.ObjectId(requestId);
    }

    const newMessage = new Message({
      sender: senderId,
      receiver: receiverId,
      content,
      ...messageContext, // Add dataset or request if present
      read: false,
    });

    await newMessage.save();

    // Populate sender and receiver for the response
    const populatedMessage = await Message.findById(newMessage._id)
      .populate('sender', 'name avatar')
      .populate('receiver', 'name avatar');

    res.status(201).json({
      message: 'Message sent successfully',
      messageData: populatedMessage?.toObject(),
    });
  } catch (err: any) {
    console.error('[messages] Send error:', err);
    res.status(500).json({ error: 'Failed to send message', details: err.message });
  }
});

// GET /api/messages/conversation/:otherUserId - Get conversation between current user and another user
router.get('/conversation/:otherUserId', protect, async (req: AuthRequest, res: Response) => {
  try {
    const currentUserId = req.user?.userId;
    const { otherUserId } = req.params;
    const { datasetId, requestId, limit = 50, skip = 0 } = req.query; // Add pagination

    if (!currentUserId) {
      return res.status(401).json({ error: 'Unauthorized: User ID missing.' });
    }
    if (!mongoose.Types.ObjectId.isValid(otherUserId)) {
        return res.status(400).json({ error: 'Invalid other user ID format.' });
    }

    // Build query to find messages between these two users
    // Messages where current user is sender and other is receiver OR vice versa
    const query: any = {
      $or: [
        { sender: currentUserId, receiver: otherUserId },
        { sender: otherUserId, receiver: currentUserId },
      ],
    };

    // Define messageContext for this specific route's updateMany call
    let messageContextForUpdate: { dataset?: mongoose.Types.ObjectId; request?: mongoose.Types.ObjectId } = {};

    // Add context to query if provided
    if (datasetId) {
      if (!mongoose.Types.ObjectId.isValid(datasetId as string)) {
          return res.status(400).json({ error: 'Invalid dataset ID format.' });
      }
      query.dataset = new mongoose.Types.ObjectId(datasetId as string);
      messageContextForUpdate.dataset = new mongoose.Types.ObjectId(datasetId as string);
    }
    if (requestId) {
      if (!mongoose.Types.ObjectId.isValid(requestId as string)) {
          return res.status(400).json({ error: 'Invalid request ID format.' });
      }
      query.request = new mongoose.Types.ObjectId(requestId as string);
      messageContextForUpdate.request = new mongoose.Types.ObjectId(requestId as string);
    }

    const messages = await Message.find(query)
      .sort({ createdAt: 1 }) // Sort by oldest first for conversation flow
      .skip(Number(skip))
      .limit(Number(limit))
      .populate('sender', 'name avatar') // Populate sender's name and avatar
      .populate('receiver', 'name avatar'); // Populate receiver's name and avatar

    // Mark messages sent by 'otherUserId' to 'currentUserId' as read
    // Ensure messageContextForUpdate is used here
    await Message.updateMany(
      { receiver: currentUserId, sender: otherUserId, read: false, ...messageContextForUpdate },
      { $set: { read: true } }
    );

    res.json(messages.map(msg => msg.toObject()));
  } catch (err: any) {
    console.error('[messages] Get conversation error:', err);
    res.status(500).json({ error: 'Failed to fetch conversation', details: err.message });
  }
});

// GET /api/messages/unread-count - Get unread message count for current user
router.get('/unread-count', protect, async (req: AuthRequest, res: Response) => {
  try {
    const currentUserId = req.user?.userId;
    if (!currentUserId) {
      return res.status(401).json({ error: 'Unauthorized: User ID missing.' });
    }

    const unreadCount = await Message.countDocuments({
      receiver: currentUserId,
      read: false,
    });

    res.json({ unreadCount });
  } catch (err: any) {
    console.error('[messages] Get unread count error:', err);
    res.status(500).json({ error: 'Failed to fetch unread count', details: err.message });
  }
});

// GET /api/messages/recent-conversations - Get a list of users with whom the current user has recent conversations
router.get('/recent-conversations', protect, async (req: AuthRequest, res: Response) => {
    try {
        const currentUserId = req.user?.userId;
        if (!currentUserId) {
            return res.status(401).json({ error: 'Unauthorized: User ID missing.' });
        }

        // Aggregate to find distinct conversation partners and their last message
        const conversations = await Message.aggregate([
            {
                $match: {
                    $or: [
                        { sender: new mongoose.Types.ObjectId(currentUserId) },
                        { receiver: new mongoose.Types.ObjectId(currentUserId) }
                    ]
                }
            },
            {
                $sort: { createdAt: -1 } // Sort by most recent message first
            },
            {
                $group: {
                    _id: {
                        $cond: {
                            if: { $eq: ["$sender", new mongoose.Types.ObjectId(currentUserId)] },
                            then: "$receiver",
                            else: "$sender"
                        }
                    },
                    lastMessage: { $first: "$content" },
                    lastMessageTime: { $first: "$createdAt" },
                    unreadCount: {
                        $sum: {
                            $cond: [
                                { $and: [{ $eq: ["$receiver", new mongoose.Types.ObjectId(currentUserId)] }, { $eq: ["$read", false] }] },
                                1,
                                0
                            ]
                        }
                    },
                    lastMessageId: { $first: "$_id" } // Keep track of the last message ID
                }
            },
            {
                $lookup: {
                    from: 'users', // The name of the users collection in MongoDB
                    localField: '_id',
                    foreignField: '_id',
                    as: 'participant'
                }
            },
            {
                $unwind: '$participant'
            },
            {
                $project: {
                    _id: 0, // Exclude _id from the root
                    participantId: '$participant._id',
                    participantName: '$participant.name',
                    participantAvatar: '$participant.avatar',
                    lastMessage: 1,
                    lastMessageTime: 1,
                    unreadCount: 1,
                    lastMessageId: 1 // Include last message ID
                }
            },
            {
                $sort: { lastMessageTime: -1 } // Sort conversations by most recent message
            }
        ]);

        res.json(conversations);
    } catch (err: any) {
        console.error('[messages] Get recent conversations error:', err);
        res.status(500).json({ error: 'Failed to fetch recent conversations', details: err.message });
    }
});


export default router;

backend\src\routes\payment.routes.ts:
// backend/src/routes/payment.routes.ts
import express from 'express';
import { protect } from '../middleware/authMiddleware';
import { createPaymentIntent } from '../controllers/payment.controller';

const router = express.Router();

router.post('/create-payment-intent', protect, createPaymentIntent);

export default router;
backend\src\routes\proposal.routes.ts:
// backend/src/routes/proposal.routes.ts
import express from 'express';
import { protect } from '../middleware/authMiddleware';
import {
    createProposal,
    getProposalsForRequest,
    getSentProposals, // NEW: Import the new controller
    acceptProposal,
    completeProposal,
    releaseFunds,
} from '../controllers/proposal.controller';

const router = express.Router();

// All routes in this file are protected
router.use(protect);

// Create a new proposal
router.post('/', createProposal);

// NEW: Get all proposals sent by the current seller
router.get('/sent', getSentProposals);

// Get all proposals for a specific request
router.get('/request/:requestId', getProposalsForRequest);

// Buyer accepts a proposal (initiates escrow)
router.put('/:id/accept', acceptProposal);

// Seller marks a proposal as complete
router.put('/:id/complete', completeProposal);

// Buyer releases funds from escrow
router.post('/:id/release-funds', releaseFunds);

export default router;

backend\src\routes\purchase.routes.ts:
// backend/src/routes/purchase.routes.ts
import express from 'express';
import { protect } from '../middleware/authMiddleware';
import { getMyPurchases } from '../controllers/purchase.controller';

const router = express.Router();

// All routes in this file are protected
router.use(protect);

router.get('/me', getMyPurchases);

export default router;
backend\src\routes\stripeConnect.routes.ts:
// backend/src/routes/stripeConnect.routes.ts
import express from 'express';
import { protect } from '../middleware/authMiddleware';
import { onboardSeller, getAccountStatus } from '../controllers/stripeConnect.controller';

const router = express.Router();

// All routes here are protected
router.use(protect);

// Route to initiate seller onboarding
router.post('/onboard-seller', onboardSeller);

// Route to check the seller's Stripe account status
router.get('/account-status', getAccountStatus);

export default router;

backend\src\routes\user.routes.ts:
import express from 'express';
import { protect } from '../middleware/authMiddleware';
import { uploadAvatar } from '../middleware/upload';
import { getUserProfile, updateUserProfile, uploadUserAvatar } from '../controllers/user.controller';

const router = express.Router();

router.use(protect);

router.route('/me')
  .get(getUserProfile)
  .put(updateUserProfile);

router.post('/me/avatar', uploadAvatar.single('avatar'), uploadUserAvatar);

export default router;

backend\src\server.ts:
// backend/src/server.ts

// =================================================================
// IMPORTS
// =================================================================
import express, { Request, Response, NextFunction } from 'express';
import dotenv from 'dotenv';
import cors from 'cors';
import morgan from 'morgan';
import path from 'path';
import fs from 'fs';
import mongoose from 'mongoose';
import Stripe from 'stripe'; // Import Stripe for type checking in error handler

// Initialize dotenv to load environment variables
dotenv.config();

// Custom Modules & Library Imports
import { connectDB } from './lib/db';
import { handleStripeWebhook } from './controllers/payment.controller'; // Webhook handler is in payment controller

// Route Imports
import authRoutes from './routes/auth.routes';
import userRoutes from './routes/user.routes';
import datasetRoutes from './routes/dataset.routes';
import datasetRequestRoutes from './routes/datasetRequest.routes';
import proposalRoutes from './routes/proposal.routes';
import messageRoutes from './routes/message.routes';
import paymentRoutes from './routes/payment.routes';
import stripeConnectRoutes from './routes/stripeConnect.routes';
import purchaseRoutes from './routes/purchase.routes';

// =================================================================
// INITIALIZATION
// =================================================================
const app = express();
const PORT = process.env.PORT || 5000;
const isProduction = process.env.NODE_ENV === 'production';

// =================================================================
// CORE MIDDLEWARE
// =================================================================

// --- CORS Configuration ---
const allowedOrigins = [
    process.env.CLIENT_ORIGIN || 'http://localhost:5173',
    'http://localhost:8080', // ADD THIS LINE: Your frontend's actual running URL from screenshot
];

const corsOptions: cors.CorsOptions = {
    origin: (origin, callback) => {
        if (!origin) return callback(null, true);
        if (allowedOrigins.indexOf(origin) === -1) {
            const msg = 'The CORS policy for this site does not allow access from the specified Origin.';
            return callback(new Error(msg), false);
        }
        return callback(null, true);
    },
    credentials: true,
};

app.use(cors(corsOptions));


// Logger: 'dev' for development, 'combined' for production
app.use(morgan(isProduction ? 'combined' : 'dev'));

// IMPORTANT: Stripe webhook endpoint must be registered before express.json()
app.post('/api/payments/webhook', express.raw({ type: 'application/json' }), handleStripeWebhook);

// Standard body parsers
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// =================================================================
// API ROUTES
// =================================================================
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/datasets', datasetRoutes);
app.use('/api/requests', datasetRequestRoutes);
app.use('/api/proposals', proposalRoutes);
app.use('/api/messages', messageRoutes);
app.use('/api/payments', paymentRoutes);
app.use('/api/stripe', stripeConnectRoutes);
app.use('/api/purchases', purchaseRoutes);

// =================================================================
// STATIC ASSETS & HEALTH CHECK
// =================================================================
// Ensure uploads directory and its subdirectories exist
const uploadsBaseDir = path.join(__dirname, '..', 'uploads');
const avatarsDir = path.join(uploadsBaseDir, 'avatars');
const datasetsDir = path.join(uploadsBaseDir, 'datasets');

// Ensure directories exist on server startup
if (!fs.existsSync(uploadsBaseDir)) fs.mkdirSync(uploadsBaseDir, { recursive: true });
if (!fs.existsSync(avatarsDir)) fs.mkdirSync(avatarsDir, { recursive: true });
if (!fs.existsSync(datasetsDir)) fs.mkdirSync(datasetsDir, { recursive: true });

app.use('/uploads', express.static(uploadsBaseDir));
app.get('/', (_req: Request, res: Response) => {
    res.status(200).json({ status: 'ok', message: 'DataNestX API is running' });
});

// =================================================================
// ERROR HANDLING
// =================================================================
// Catch-all for 404 Not Found
app.use((_req: Request, res: Response) => {
    res.status(404).json({ error: 'Endpoint not found' });
});

// Global Error Handler (Centralized error handling)
app.use((err: Error, _req: Request, res: Response, _next: NextFunction) => {
    console.error('Global Error Handler:', err.stack || err);

    // Mongoose validation errors
    if (err instanceof mongoose.Error.ValidationError) {
        return res.status(400).json({ error: err.message, details: err.errors });
    }
    // JWT authentication errors
    if (err.name === 'JsonWebTokenError' || err.name === 'TokenExpiredError') {
        return res.status(401).json({ error: 'Unauthorized: Invalid or expired token.' });
    }
    // Multer errors (file upload errors)
    if (err.name === 'MulterError') {
        return res.status(400).json({ error: `File upload error: ${err.message}` });
    }
    // Stripe errors (basic handling, more specific handling in controllers)
    // Cast err to Stripe.StripeError to access Stripe-specific properties
    if (err.name === 'StripeCardError' || err.name === 'StripeInvalidRequestError' || err.name === 'StripeAPIError' || err.name === 'StripeConnectionError' || err.name === 'StripeAuthenticationError' || err.name === 'StripeRateLimitError') {
        const stripeError = err as Stripe.StripeError; // Explicitly cast to Stripe.StripeError
        return res.status(stripeError.statusCode || 500).json({ error: stripeError.message, stripeCode: stripeError.code });
    }

    // Generic server error
    res.status(500).json({
        error: 'Unexpected server error',
        details: isProduction ? undefined : err.message, // Hide details in production
    });
});

// =================================================================
// SERVER STARTUP
// =================================================================
const startServer = async () => {
    try {
        await connectDB();
        app.listen(PORT, () => {
            console.log(`✅ Server running on http://localhost:${PORT} in ${process.env.NODE_ENV || 'development'} mode`);
        });
    } catch (err) {
        console.error('❌ Failed to connect to database:', err);
        process.exit(1); // Exit process on DB connection failure
    }
};

startServer();
export default app;


